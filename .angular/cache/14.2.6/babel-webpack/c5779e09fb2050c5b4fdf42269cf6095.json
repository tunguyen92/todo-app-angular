{"ast":null,"code":"/**\n * @license Angular v9.1.13\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\nimport { ɵDomAdapter, ɵsetRootDomAdapter, ɵparseCookieValue, ɵgetDOM, DOCUMENT, ɵPLATFORM_BROWSER_ID, CommonModule } from '@angular/common';\nimport * as ɵngcc0 from '@angular/core';\nexport { ɵgetDOM } from '@angular/common';\nimport { ɵglobal, InjectionToken, ApplicationInitStatus, APP_INITIALIZER, Injector, setTestabilityGetter, ApplicationRef, NgZone, ɵgetDebugNodeR2, NgProbeToken, Optional, Injectable, Inject, ViewEncapsulation, APP_ID, RendererStyleFlags2, ɵConsole, NgModule, forwardRef, ɵɵdefineInjectable, ɵɵinject, SecurityContext, ɵallowSanitizationBypassAndThrow, ɵunwrapSafeValue, ɵgetSanitizationBypassType, ɵ_sanitizeUrl, ɵ_sanitizeStyle, ɵ_sanitizeHtml, ɵbypassSanitizationTrustHtml, ɵbypassSanitizationTrustStyle, ɵbypassSanitizationTrustScript, ɵbypassSanitizationTrustUrl, ɵbypassSanitizationTrustResourceUrl, INJECTOR, ErrorHandler, ɵsetDocument, PLATFORM_ID, PLATFORM_INITIALIZER, Sanitizer, createPlatformFactory, platformCore, ɵINJECTOR_SCOPE, RendererFactory2, Testability, ApplicationModule, SkipSelf, Version } from '@angular/core';\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/browser/generic_browser_adapter.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Provides DOM operations in any browser environment.\n *\n * \\@security Tread carefully! Interacting with the DOM directly is dangerous and\n * can introduce XSS risks.\n * @abstract\n */\n\nclass GenericBrowserDomAdapter extends ɵDomAdapter {\n  constructor() {\n    super();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  supportsDOMEvents() {\n    return true;\n  }\n\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/browser/browser_adapter.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nconst ɵ0 =\n/**\n* @return {?}\n*/\n() => {\n  if (ɵglobal['Node']) {\n    return ɵglobal['Node'].prototype.contains ||\n    /**\n    * @this {?}\n    * @param {?} node\n    * @return {?}\n    */\n    function (node) {\n      return !!(this.compareDocumentPosition(node) & 16);\n    };\n  }\n\n  return (\n    /** @type {?} */\n    undefined\n  );\n};\n/** @type {?} */\n\n\nconst nodeContains = /*#__PURE__*/ɵ0();\n/**\n * A `DomAdapter` powered by full browser DOM APIs.\n *\n * \\@security Tread carefully! Interacting with the DOM directly is dangerous and\n * can introduce XSS risks.\n */\n\n/* tslint:disable:requireParameterType no-console */\n\nclass BrowserDomAdapter extends GenericBrowserDomAdapter {\n  /**\n   * @return {?}\n   */\n  static makeCurrent() {\n    ɵsetRootDomAdapter(new BrowserDomAdapter());\n  }\n  /**\n   * @param {?} el\n   * @param {?} name\n   * @return {?}\n   */\n\n\n  getProperty(el, name) {\n    return (\n      /** @type {?} */\n      el[name]\n    );\n  }\n  /**\n   * @param {?} error\n   * @return {?}\n   */\n\n\n  log(error) {\n    if (window.console) {\n      window.console.log && window.console.log(error);\n    }\n  }\n  /**\n   * @param {?} error\n   * @return {?}\n   */\n\n\n  logGroup(error) {\n    if (window.console) {\n      window.console.group && window.console.group(error);\n    }\n  }\n  /**\n   * @return {?}\n   */\n\n\n  logGroupEnd() {\n    if (window.console) {\n      window.console.groupEnd && window.console.groupEnd();\n    }\n  }\n  /**\n   * @param {?} el\n   * @param {?} evt\n   * @param {?} listener\n   * @return {?}\n   */\n\n\n  onAndCancel(el, evt, listener) {\n    el.addEventListener(evt, listener, false); // Needed to follow Dart's subscription semantic, until fix of\n    // https://code.google.com/p/dart/issues/detail?id=17406\n\n    return (\n      /**\n      * @return {?}\n      */\n      () => {\n        el.removeEventListener(evt, listener, false);\n      }\n    );\n  }\n  /**\n   * @param {?} el\n   * @param {?} evt\n   * @return {?}\n   */\n\n\n  dispatchEvent(el, evt) {\n    el.dispatchEvent(evt);\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n\n\n  remove(node) {\n    if (node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n\n    return node;\n  }\n  /**\n   * @param {?} el\n   * @return {?}\n   */\n\n\n  getValue(el) {\n    return el.value;\n  }\n  /**\n   * @param {?} tagName\n   * @param {?=} doc\n   * @return {?}\n   */\n\n\n  createElement(tagName, doc) {\n    doc = doc || this.getDefaultDocument();\n    return doc.createElement(tagName);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  createHtmlDocument() {\n    return document.implementation.createHTMLDocument('fakeTitle');\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getDefaultDocument() {\n    return document;\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n\n\n  isElementNode(node) {\n    return node.nodeType === Node.ELEMENT_NODE;\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n\n\n  isShadowRoot(node) {\n    return node instanceof DocumentFragment;\n  }\n  /**\n   * @param {?} doc\n   * @param {?} target\n   * @return {?}\n   */\n\n\n  getGlobalEventTarget(doc, target) {\n    if (target === 'window') {\n      return window;\n    }\n\n    if (target === 'document') {\n      return doc;\n    }\n\n    if (target === 'body') {\n      return doc.body;\n    }\n\n    return null;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getHistory() {\n    return window.history;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getLocation() {\n    return window.location;\n  }\n  /**\n   * @param {?} doc\n   * @return {?}\n   */\n\n\n  getBaseHref(doc) {\n    /** @type {?} */\n    const href = getBaseElementHref();\n    return href == null ? null : relativePath(href);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  resetBaseElement() {\n    baseElement = null;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  getUserAgent() {\n    return window.navigator.userAgent;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  performanceNow() {\n    // performance.now() is not available in all browsers, see\n    // http://caniuse.com/#search=performance.now\n    return window.performance && window.performance.now ? window.performance.now() : new Date().getTime();\n  }\n  /**\n   * @return {?}\n   */\n\n\n  supportsCookies() {\n    return true;\n  }\n  /**\n   * @param {?} name\n   * @return {?}\n   */\n\n\n  getCookie(name) {\n    return ɵparseCookieValue(document.cookie, name);\n  }\n\n}\n/** @type {?} */\n\n\nlet baseElement = null;\n/**\n * @return {?}\n */\n\nfunction getBaseElementHref() {\n  if (!baseElement) {\n    baseElement =\n    /** @type {?} */\n    document.querySelector('base');\n\n    if (!baseElement) {\n      return null;\n    }\n  }\n\n  return baseElement.getAttribute('href');\n} // based on urlUtils.js in AngularJS 1\n\n/** @type {?} */\n\n\nlet urlParsingNode;\n/**\n * @param {?} url\n * @return {?}\n */\n\nfunction relativePath(url) {\n  if (!urlParsingNode) {\n    urlParsingNode = document.createElement('a');\n  }\n\n  urlParsingNode.setAttribute('href', url);\n  return urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/browser/server-transition.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * An id that identifies a particular application being bootstrapped, that should\n * match across the client/server boundary.\n * @type {?}\n */\n\n\nconst TRANSITION_ID = /*#__PURE__*/new InjectionToken('TRANSITION_ID');\n/**\n * @param {?} transitionId\n * @param {?} document\n * @param {?} injector\n * @return {?}\n */\n\nfunction appInitializerFactory(transitionId, document, injector) {\n  return (\n    /**\n    * @return {?}\n    */\n    () => {\n      // Wait for all application initializers to be completed before removing the styles set by\n      // the server.\n      injector.get(ApplicationInitStatus).donePromise.then(\n      /**\n      * @return {?}\n      */\n      () => {\n        /** @type {?} */\n        const dom = ɵgetDOM();\n        /** @type {?} */\n\n        const styles = Array.prototype.slice.apply(document.querySelectorAll(`style[ng-transition]`));\n        styles.filter(\n        /**\n        * @param {?} el\n        * @return {?}\n        */\n        el => el.getAttribute('ng-transition') === transitionId).forEach(\n        /**\n        * @param {?} el\n        * @return {?}\n        */\n        el => dom.remove(el));\n      });\n    }\n  );\n}\n/** @type {?} */\n\n\nconst SERVER_TRANSITION_PROVIDERS = [{\n  provide: APP_INITIALIZER,\n  useFactory: appInitializerFactory,\n  deps: [TRANSITION_ID, DOCUMENT, Injector],\n  multi: true\n}];\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/browser/testability.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nclass BrowserGetTestability {\n  /**\n   * @return {?}\n   */\n  static init() {\n    setTestabilityGetter(new BrowserGetTestability());\n  }\n  /**\n   * @param {?} registry\n   * @return {?}\n   */\n\n\n  addToWindow(registry) {\n    ɵglobal['getAngularTestability'] =\n    /**\n    * @param {?} elem\n    * @param {?=} findInAncestors\n    * @return {?}\n    */\n    (elem, findInAncestors = true) => {\n      /** @type {?} */\n      const testability = registry.findTestabilityInTree(elem, findInAncestors);\n\n      if (testability == null) {\n        throw new Error('Could not find testability for element.');\n      }\n\n      return testability;\n    };\n\n    ɵglobal['getAllAngularTestabilities'] =\n    /**\n    * @return {?}\n    */\n    () => registry.getAllTestabilities();\n\n    ɵglobal['getAllAngularRootElements'] =\n    /**\n    * @return {?}\n    */\n    () => registry.getAllRootElements();\n    /** @type {?} */\n\n\n    const whenAllStable =\n    /**\n    * @param {?} callback\n    * @return {?}\n    */\n    (callback\n    /** TODO #9100 */\n    ) => {\n      /** @type {?} */\n      const testabilities = ɵglobal['getAllAngularTestabilities']();\n      /** @type {?} */\n\n      let count = testabilities.length;\n      /** @type {?} */\n\n      let didWork = false;\n      /** @type {?} */\n\n      const decrement =\n      /**\n      * @param {?} didWork_\n      * @return {?}\n      */\n      function (didWork_\n      /** TODO #9100 */\n      ) {\n        didWork = didWork || didWork_;\n        count--;\n\n        if (count == 0) {\n          callback(didWork);\n        }\n      };\n\n      testabilities.forEach(\n      /**\n      * @param {?} testability\n      * @return {?}\n      */\n      function (testability\n      /** TODO #9100 */\n      ) {\n        testability.whenStable(decrement);\n      });\n    };\n\n    if (!ɵglobal['frameworkStabilizers']) {\n      ɵglobal['frameworkStabilizers'] = [];\n    }\n\n    ɵglobal['frameworkStabilizers'].push(whenAllStable);\n  }\n  /**\n   * @param {?} registry\n   * @param {?} elem\n   * @param {?} findInAncestors\n   * @return {?}\n   */\n\n\n  findTestabilityInTree(registry, elem, findInAncestors) {\n    if (elem == null) {\n      return null;\n    }\n    /** @type {?} */\n\n\n    const t = registry.getTestability(elem);\n\n    if (t != null) {\n      return t;\n    } else if (!findInAncestors) {\n      return null;\n    }\n\n    if (ɵgetDOM().isShadowRoot(elem)) {\n      return this.findTestabilityInTree(registry,\n      /** @type {?} */\n      elem.host, true);\n    }\n\n    return this.findTestabilityInTree(registry, elem.parentElement, true);\n  }\n\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/dom/util.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst CAMEL_CASE_REGEXP = /([A-Z])/g;\n/** @type {?} */\n\nconst DASH_CASE_REGEXP = /-([a-z])/g;\n/**\n * @param {?} input\n * @return {?}\n */\n\nfunction camelCaseToDashCase(input) {\n  return input.replace(CAMEL_CASE_REGEXP,\n  /**\n  * @param {...?} m\n  * @return {?}\n  */\n  (...m) => '-' + m[1].toLowerCase());\n}\n/**\n * @param {?} input\n * @return {?}\n */\n\n\nfunction dashCaseToCamelCase(input) {\n  return input.replace(DASH_CASE_REGEXP,\n  /**\n  * @param {...?} m\n  * @return {?}\n  */\n  (...m) => m[1].toUpperCase());\n}\n/**\n * Exports the value under a given `name` in the global property `ng`. For example `ng.probe` if\n * `name` is `'probe'`.\n * @param {?} name Name under which it will be exported. Keep in mind this will be a property of the\n * global `ng` object.\n * @param {?} value The value to export.\n * @return {?}\n */\n\n\nfunction exportNgVar(name, value) {\n  if (typeof COMPILED === 'undefined' || !COMPILED) {\n    // Note: we can't export `ng` when using closure enhanced optimization as:\n    // - closure declares globals itself for minified names, which sometimes clobber our `ng` global\n    // - we can't declare a closure extern as the namespace `ng` is already used within Google\n    //   for typings for angularJS (via `goog.provide('ng....')`).\n\n    /** @type {?} */\n    const ng = ɵglobal['ng'] =\n    /** @type {?} */\n    ɵglobal['ng'] || {};\n    ng[name] = value;\n  }\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/dom/debug/ng_probe.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nconst ɵ0$1 =\n/**\n* @return {?}\n*/\n() => ({\n  'ApplicationRef': ApplicationRef,\n  'NgZone': NgZone\n});\n/** @type {?} */\n\n\nconst CORE_TOKENS = /*#__PURE__*/ɵ0$1();\n/** @type {?} */\n\nconst INSPECT_GLOBAL_NAME = 'probe';\n/** @type {?} */\n\nconst CORE_TOKENS_GLOBAL_NAME = 'coreTokens';\n/**\n * Returns a {\\@link DebugElement} for the given native DOM element, or\n * null if the given native element does not have an Angular view associated\n * with it.\n * @param {?} element\n * @return {?}\n */\n\nfunction inspectNativeElementR2(element) {\n  return ɵgetDebugNodeR2(element);\n}\n/**\n * @param {?} coreTokens\n * @return {?}\n */\n\n\nfunction _createNgProbeR2(coreTokens) {\n  exportNgVar(INSPECT_GLOBAL_NAME, inspectNativeElementR2);\n  exportNgVar(CORE_TOKENS_GLOBAL_NAME, Object.assign(Object.assign({}, CORE_TOKENS), _ngProbeTokensToMap(coreTokens || [])));\n  return (\n    /**\n    * @return {?}\n    */\n    () => inspectNativeElementR2\n  );\n}\n/**\n * @param {?} tokens\n * @return {?}\n */\n\n\nfunction _ngProbeTokensToMap(tokens) {\n  return tokens.reduce(\n  /**\n  * @param {?} prev\n  * @param {?} t\n  * @return {?}\n  */\n  (prev, t) => (prev[t.name] = t.token, prev), {});\n}\n/**\n * In Ivy, we don't support NgProbe because we have our own set of testing utilities\n * with more robust functionality.\n *\n * We shouldn't bring in NgProbe because it prevents DebugNode and friends from\n * tree-shaking properly.\n * @type {?}\n */\n\n\nconst ELEMENT_PROBE_PROVIDERS__POST_R3__ = [];\n/**\n * Providers which support debugging Angular applications (e.g. via `ng.probe`).\n * @type {?}\n */\n\nconst ELEMENT_PROBE_PROVIDERS__PRE_R3__ = [{\n  provide: APP_INITIALIZER,\n  useFactory: _createNgProbeR2,\n  deps: [[NgProbeToken, /*#__PURE__*/new Optional()]],\n  multi: true\n}];\n/** @type {?} */\n\nconst ELEMENT_PROBE_PROVIDERS = ELEMENT_PROBE_PROVIDERS__PRE_R3__;\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/dom/events/event_manager.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * The injection token for the event-manager plug-in service.\n *\n * \\@publicApi\n * @type {?}\n */\n\nconst EVENT_MANAGER_PLUGINS = /*#__PURE__*/new InjectionToken('EventManagerPlugins');\n/**\n * An injectable service that provides event management for Angular\n * through a browser plug-in.\n *\n * \\@publicApi\n */\n\nlet EventManager = /*#__PURE__*/(() => {\n  class EventManager {\n    /**\n     * Initializes an instance of the event-manager service.\n     * @param {?} plugins\n     * @param {?} _zone\n     */\n    constructor(plugins, _zone) {\n      this._zone = _zone;\n      this._eventNameToPlugin = new Map();\n      plugins.forEach(\n      /**\n      * @template THIS\n      * @this {THIS}\n      * @param {?} p\n      * @return {THIS}\n      */\n      p => p.manager = this);\n      this._plugins = plugins.slice().reverse();\n    }\n    /**\n     * Registers a handler for a specific element and event.\n     *\n     * @param {?} element The HTML element to receive event notifications.\n     * @param {?} eventName The name of the event to listen for.\n     * @param {?} handler A function to call when the notification occurs. Receives the\n     * event object as an argument.\n     * @return {?} A callback function that can be used to remove the handler.\n     */\n\n\n    addEventListener(element, eventName, handler) {\n      /** @type {?} */\n      const plugin = this._findPluginFor(eventName);\n\n      return plugin.addEventListener(element, eventName, handler);\n    }\n    /**\n     * Registers a global handler for an event in a target view.\n     *\n     * @param {?} target A target for global event notifications. One of \"window\", \"document\", or \"body\".\n     * @param {?} eventName The name of the event to listen for.\n     * @param {?} handler A function to call when the notification occurs. Receives the\n     * event object as an argument.\n     * @return {?} A callback function that can be used to remove the handler.\n     */\n\n\n    addGlobalEventListener(target, eventName, handler) {\n      /** @type {?} */\n      const plugin = this._findPluginFor(eventName);\n\n      return plugin.addGlobalEventListener(target, eventName, handler);\n    }\n    /**\n     * Retrieves the compilation zone in which event listeners are registered.\n     * @return {?}\n     */\n\n\n    getZone() {\n      return this._zone;\n    }\n    /**\n     * \\@internal\n     * @param {?} eventName\n     * @return {?}\n     */\n\n\n    _findPluginFor(eventName) {\n      /** @type {?} */\n      const plugin = this._eventNameToPlugin.get(eventName);\n\n      if (plugin) {\n        return plugin;\n      }\n      /** @type {?} */\n\n\n      const plugins = this._plugins;\n\n      for (let i = 0; i < plugins.length; i++) {\n        /** @type {?} */\n        const plugin = plugins[i];\n\n        if (plugin.supports(eventName)) {\n          this._eventNameToPlugin.set(eventName, plugin);\n\n          return plugin;\n        }\n      }\n\n      throw new Error(`No event manager plugin found for event ${eventName}`);\n    }\n\n  }\n\n  EventManager.ɵfac = function EventManager_Factory(t) {\n    return new (t || EventManager)(ɵngcc0.ɵɵinject(EVENT_MANAGER_PLUGINS), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n  };\n\n  EventManager.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: EventManager,\n    factory: EventManager.ɵfac\n  });\n  /** @nocollapse */\n\n  return EventManager;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  EventManager.prototype._plugins;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  EventManager.prototype._eventNameToPlugin;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  EventManager.prototype._zone;\n}\n/**\n * @abstract\n */\n\n\nclass EventManagerPlugin {\n  /**\n   * @param {?} _doc\n   */\n  constructor(_doc) {\n    this._doc = _doc;\n  }\n  /**\n   * @param {?} element\n   * @param {?} eventName\n   * @param {?} handler\n   * @return {?}\n   */\n\n\n  addGlobalEventListener(element, eventName, handler) {\n    /** @type {?} */\n    const target = ɵgetDOM().getGlobalEventTarget(this._doc, element);\n\n    if (!target) {\n      throw new Error(`Unsupported event target ${target} for event ${eventName}`);\n    }\n\n    return this.addEventListener(target, eventName, handler);\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  EventManagerPlugin.prototype.manager;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  EventManagerPlugin.prototype._doc;\n  /**\n   * @abstract\n   * @param {?} eventName\n   * @return {?}\n   */\n\n  EventManagerPlugin.prototype.supports = function (eventName) {};\n  /**\n   * @abstract\n   * @param {?} element\n   * @param {?} eventName\n   * @param {?} handler\n   * @return {?}\n   */\n\n\n  EventManagerPlugin.prototype.addEventListener = function (element, eventName, handler) {};\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/dom/shared_styles_host.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet SharedStylesHost = /*#__PURE__*/(() => {\n  class SharedStylesHost {\n    constructor() {\n      /**\n       * \\@internal\n       */\n      this._stylesSet = new Set();\n    }\n    /**\n     * @param {?} styles\n     * @return {?}\n     */\n\n\n    addStyles(styles) {\n      /** @type {?} */\n      const additions = new Set();\n      styles.forEach(\n      /**\n      * @param {?} style\n      * @return {?}\n      */\n      style => {\n        if (!this._stylesSet.has(style)) {\n          this._stylesSet.add(style);\n\n          additions.add(style);\n        }\n      });\n      this.onStylesAdded(additions);\n    }\n    /**\n     * @param {?} additions\n     * @return {?}\n     */\n\n\n    onStylesAdded(additions) {}\n    /**\n     * @return {?}\n     */\n\n\n    getAllStyles() {\n      return Array.from(this._stylesSet);\n    }\n\n  }\n\n  SharedStylesHost.ɵfac = function SharedStylesHost_Factory(t) {\n    return new (t || SharedStylesHost)();\n  };\n\n  SharedStylesHost.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: SharedStylesHost,\n    factory: SharedStylesHost.ɵfac\n  });\n  return SharedStylesHost;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * \\@internal\n   * @type {?}\n   * @protected\n   */\n  SharedStylesHost.prototype._stylesSet;\n}\n\nlet DomSharedStylesHost = /*#__PURE__*/(() => {\n  class DomSharedStylesHost extends SharedStylesHost {\n    /**\n     * @param {?} _doc\n     */\n    constructor(_doc) {\n      super();\n      this._doc = _doc;\n      this._hostNodes = new Set();\n      this._styleNodes = new Set();\n\n      this._hostNodes.add(_doc.head);\n    }\n    /**\n     * @private\n     * @param {?} styles\n     * @param {?} host\n     * @return {?}\n     */\n\n\n    _addStylesToHost(styles, host) {\n      styles.forEach(\n      /**\n      * @param {?} style\n      * @return {?}\n      */\n      style => {\n        /** @type {?} */\n        const styleEl = this._doc.createElement('style');\n\n        styleEl.textContent = style;\n\n        this._styleNodes.add(host.appendChild(styleEl));\n      });\n    }\n    /**\n     * @param {?} hostNode\n     * @return {?}\n     */\n\n\n    addHost(hostNode) {\n      this._addStylesToHost(this._stylesSet, hostNode);\n\n      this._hostNodes.add(hostNode);\n    }\n    /**\n     * @param {?} hostNode\n     * @return {?}\n     */\n\n\n    removeHost(hostNode) {\n      this._hostNodes.delete(hostNode);\n    }\n    /**\n     * @param {?} additions\n     * @return {?}\n     */\n\n\n    onStylesAdded(additions) {\n      this._hostNodes.forEach(\n      /**\n      * @param {?} hostNode\n      * @return {?}\n      */\n      hostNode => this._addStylesToHost(additions, hostNode));\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this._styleNodes.forEach(\n      /**\n      * @param {?} styleNode\n      * @return {?}\n      */\n      styleNode => ɵgetDOM().remove(styleNode));\n    }\n\n  }\n\n  DomSharedStylesHost.ɵfac = function DomSharedStylesHost_Factory(t) {\n    return new (t || DomSharedStylesHost)(ɵngcc0.ɵɵinject(DOCUMENT));\n  };\n\n  DomSharedStylesHost.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: DomSharedStylesHost,\n    factory: DomSharedStylesHost.ɵfac\n  });\n  /** @nocollapse */\n\n  return DomSharedStylesHost;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  DomSharedStylesHost.prototype._hostNodes;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DomSharedStylesHost.prototype._styleNodes;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DomSharedStylesHost.prototype._doc;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/dom/dom_renderer.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst NAMESPACE_URIS = {\n  'svg': 'http://www.w3.org/2000/svg',\n  'xhtml': 'http://www.w3.org/1999/xhtml',\n  'xlink': 'http://www.w3.org/1999/xlink',\n  'xml': 'http://www.w3.org/XML/1998/namespace',\n  'xmlns': 'http://www.w3.org/2000/xmlns/'\n};\n/** @type {?} */\n\nconst COMPONENT_REGEX = /%COMP%/g;\n/** @type {?} */\n\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || !!ngDevMode;\n/** @type {?} */\n\nconst COMPONENT_VARIABLE = '%COMP%';\n/** @type {?} */\n\nconst HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\n/** @type {?} */\n\nconst CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\n/**\n * @param {?} componentShortId\n * @return {?}\n */\n\nfunction shimContentAttribute(componentShortId) {\n  return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);\n}\n/**\n * @param {?} componentShortId\n * @return {?}\n */\n\n\nfunction shimHostAttribute(componentShortId) {\n  return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);\n}\n/**\n * @param {?} compId\n * @param {?} styles\n * @param {?} target\n * @return {?}\n */\n\n\nfunction flattenStyles(compId, styles, target) {\n  for (let i = 0; i < styles.length; i++) {\n    /** @type {?} */\n    let style = styles[i];\n\n    if (Array.isArray(style)) {\n      flattenStyles(compId, style, target);\n    } else {\n      style = style.replace(COMPONENT_REGEX, compId);\n      target.push(style);\n    }\n  }\n\n  return target;\n}\n/**\n * @param {?} eventHandler\n * @return {?}\n */\n\n\nfunction decoratePreventDefault(eventHandler) {\n  // `DebugNode.triggerEventHandler` needs to know if the listener was created with\n  // decoratePreventDefault or is a listener added outside the Angular context so it can handle the\n  // two differently. In the first case, the special '__ngUnwrap__' token is passed to the unwrap\n  // the listener (see below).\n  return (\n    /**\n    * @param {?} event\n    * @return {?}\n    */\n    event => {\n      // Ivy uses '__ngUnwrap__' as a special token that allows us to unwrap the function\n      // so that it can be invoked programmatically by `DebugNode.triggerEventHandler`. The debug_node\n      // can inspect the listener toString contents for the existence of this special token. Because\n      // the token is a string literal, it is ensured to not be modified by compiled code.\n      if (event === '__ngUnwrap__') {\n        return eventHandler;\n      }\n      /** @type {?} */\n\n\n      const allowDefaultBehavior = eventHandler(event);\n\n      if (allowDefaultBehavior === false) {\n        // TODO(tbosch): move preventDefault into event plugins...\n        event.preventDefault();\n        event.returnValue = false;\n      }\n\n      return undefined;\n    }\n  );\n}\n\nlet DomRendererFactory2 = /*#__PURE__*/(() => {\n  class DomRendererFactory2 {\n    /**\n     * @param {?} eventManager\n     * @param {?} sharedStylesHost\n     * @param {?} appId\n     */\n    constructor(eventManager, sharedStylesHost, appId) {\n      this.eventManager = eventManager;\n      this.sharedStylesHost = sharedStylesHost;\n      this.appId = appId;\n      this.rendererByCompId = new Map();\n      this.defaultRenderer = new DefaultDomRenderer2(eventManager);\n    }\n    /**\n     * @param {?} element\n     * @param {?} type\n     * @return {?}\n     */\n\n\n    createRenderer(element, type) {\n      if (!element || !type) {\n        return this.defaultRenderer;\n      }\n\n      switch (type.encapsulation) {\n        case ViewEncapsulation.Emulated:\n          {\n            /** @type {?} */\n            let renderer = this.rendererByCompId.get(type.id);\n\n            if (!renderer) {\n              renderer = new EmulatedEncapsulationDomRenderer2(this.eventManager, this.sharedStylesHost, type, this.appId);\n              this.rendererByCompId.set(type.id, renderer);\n            }\n\n            /** @type {?} */\n            renderer.applyToHost(element);\n            return renderer;\n          }\n\n        case ViewEncapsulation.Native:\n        case ViewEncapsulation.ShadowDom:\n          return new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);\n\n        default:\n          {\n            if (!this.rendererByCompId.has(type.id)) {\n              /** @type {?} */\n              const styles = flattenStyles(type.id, type.styles, []);\n              this.sharedStylesHost.addStyles(styles);\n              this.rendererByCompId.set(type.id, this.defaultRenderer);\n            }\n\n            return this.defaultRenderer;\n          }\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    begin() {}\n    /**\n     * @return {?}\n     */\n\n\n    end() {}\n\n  }\n\n  DomRendererFactory2.ɵfac = function DomRendererFactory2_Factory(t) {\n    return new (t || DomRendererFactory2)(ɵngcc0.ɵɵinject(EventManager), ɵngcc0.ɵɵinject(DomSharedStylesHost), ɵngcc0.ɵɵinject(APP_ID));\n  };\n\n  DomRendererFactory2.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: DomRendererFactory2,\n    factory: DomRendererFactory2.ɵfac\n  });\n  /** @nocollapse */\n\n  return DomRendererFactory2;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  DomRendererFactory2.prototype.rendererByCompId;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DomRendererFactory2.prototype.defaultRenderer;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DomRendererFactory2.prototype.eventManager;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DomRendererFactory2.prototype.sharedStylesHost;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DomRendererFactory2.prototype.appId;\n}\n\nclass DefaultDomRenderer2 {\n  /**\n   * @param {?} eventManager\n   */\n  constructor(eventManager) {\n    this.eventManager = eventManager;\n    this.data = Object.create(null);\n  }\n  /**\n   * @return {?}\n   */\n\n\n  destroy() {}\n  /**\n   * @param {?} name\n   * @param {?=} namespace\n   * @return {?}\n   */\n\n\n  createElement(name, namespace) {\n    if (namespace) {\n      // In cases where Ivy (not ViewEngine) is giving us the actual namespace, the look up by key\n      // will result in undefined, so we just return the namespace here.\n      return document.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);\n    }\n\n    return document.createElement(name);\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  createComment(value) {\n    return document.createComment(value);\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  createText(value) {\n    return document.createTextNode(value);\n  }\n  /**\n   * @param {?} parent\n   * @param {?} newChild\n   * @return {?}\n   */\n\n\n  appendChild(parent, newChild) {\n    parent.appendChild(newChild);\n  }\n  /**\n   * @param {?} parent\n   * @param {?} newChild\n   * @param {?} refChild\n   * @return {?}\n   */\n\n\n  insertBefore(parent, newChild, refChild) {\n    if (parent) {\n      parent.insertBefore(newChild, refChild);\n    }\n  }\n  /**\n   * @param {?} parent\n   * @param {?} oldChild\n   * @return {?}\n   */\n\n\n  removeChild(parent, oldChild) {\n    if (parent) {\n      parent.removeChild(oldChild);\n    }\n  }\n  /**\n   * @param {?} selectorOrNode\n   * @param {?=} preserveContent\n   * @return {?}\n   */\n\n\n  selectRootElement(selectorOrNode, preserveContent) {\n    /** @type {?} */\n    let el = typeof selectorOrNode === 'string' ? document.querySelector(selectorOrNode) : selectorOrNode;\n\n    if (!el) {\n      throw new Error(`The selector \"${selectorOrNode}\" did not match any elements`);\n    }\n\n    if (!preserveContent) {\n      el.textContent = '';\n    }\n\n    return el;\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n\n\n  parentNode(node) {\n    return node.parentNode;\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n\n\n  nextSibling(node) {\n    return node.nextSibling;\n  }\n  /**\n   * @param {?} el\n   * @param {?} name\n   * @param {?} value\n   * @param {?=} namespace\n   * @return {?}\n   */\n\n\n  setAttribute(el, name, value, namespace) {\n    if (namespace) {\n      name = namespace + ':' + name; // TODO(FW-811): Ivy may cause issues here because it's passing around\n      // full URIs for namespaces, therefore this lookup will fail.\n\n      /** @type {?} */\n\n      const namespaceUri = NAMESPACE_URIS[namespace];\n\n      if (namespaceUri) {\n        el.setAttributeNS(namespaceUri, name, value);\n      } else {\n        el.setAttribute(name, value);\n      }\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n  /**\n   * @param {?} el\n   * @param {?} name\n   * @param {?=} namespace\n   * @return {?}\n   */\n\n\n  removeAttribute(el, name, namespace) {\n    if (namespace) {\n      // TODO(FW-811): Ivy may cause issues here because it's passing around\n      // full URIs for namespaces, therefore this lookup will fail.\n\n      /** @type {?} */\n      const namespaceUri = NAMESPACE_URIS[namespace];\n\n      if (namespaceUri) {\n        el.removeAttributeNS(namespaceUri, name);\n      } else {\n        // TODO(FW-811): Since ivy is passing around full URIs for namespaces\n        // this could result in properties like `http://www.w3.org/2000/svg:cx=\"123\"`,\n        // which is wrong.\n        el.removeAttribute(`${namespace}:${name}`);\n      }\n    } else {\n      el.removeAttribute(name);\n    }\n  }\n  /**\n   * @param {?} el\n   * @param {?} name\n   * @return {?}\n   */\n\n\n  addClass(el, name) {\n    el.classList.add(name);\n  }\n  /**\n   * @param {?} el\n   * @param {?} name\n   * @return {?}\n   */\n\n\n  removeClass(el, name) {\n    el.classList.remove(name);\n  }\n  /**\n   * @param {?} el\n   * @param {?} style\n   * @param {?} value\n   * @param {?} flags\n   * @return {?}\n   */\n\n\n  setStyle(el, style, value, flags) {\n    if (flags & RendererStyleFlags2.DashCase) {\n      el.style.setProperty(style, value, !!(flags & RendererStyleFlags2.Important) ? 'important' : '');\n    } else {\n      el.style[style] = value;\n    }\n  }\n  /**\n   * @param {?} el\n   * @param {?} style\n   * @param {?} flags\n   * @return {?}\n   */\n\n\n  removeStyle(el, style, flags) {\n    if (flags & RendererStyleFlags2.DashCase) {\n      el.style.removeProperty(style);\n    } else {\n      // IE requires '' instead of null\n      // see https://github.com/angular/angular/issues/7916\n      el.style[style] = '';\n    }\n  }\n  /**\n   * @param {?} el\n   * @param {?} name\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  setProperty(el, name, value) {\n    NG_DEV_MODE && checkNoSyntheticProp(name, 'property');\n    el[name] = value;\n  }\n  /**\n   * @param {?} node\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  setValue(node, value) {\n    node.nodeValue = value;\n  }\n  /**\n   * @param {?} target\n   * @param {?} event\n   * @param {?} callback\n   * @return {?}\n   */\n\n\n  listen(target, event, callback) {\n    NG_DEV_MODE && checkNoSyntheticProp(event, 'listener');\n\n    if (typeof target === 'string') {\n      return (\n        /** @type {?} */\n        this.eventManager.addGlobalEventListener(target, event, decoratePreventDefault(callback))\n      );\n    }\n\n    return (\n      /** @type {?} */\n\n      /** @type {?} */\n      this.eventManager.addEventListener(target, event, decoratePreventDefault(callback))\n    );\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  DefaultDomRenderer2.prototype.data;\n  /** @type {?} */\n\n  DefaultDomRenderer2.prototype.destroyNode;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DefaultDomRenderer2.prototype.eventManager;\n}\n\nconst ɵ0$2 =\n/**\n* @return {?}\n*/\n() => '@'.charCodeAt(0);\n/** @type {?} */\n\n\nconst AT_CHARCODE = /*#__PURE__*/ɵ0$2();\n/**\n * @param {?} name\n * @param {?} nameKind\n * @return {?}\n */\n\nfunction checkNoSyntheticProp(name, nameKind) {\n  if (name.charCodeAt(0) === AT_CHARCODE) {\n    throw new Error(`Found the synthetic ${nameKind} ${name}. Please include either \"BrowserAnimationsModule\" or \"NoopAnimationsModule\" in your application.`);\n  }\n}\n\nclass EmulatedEncapsulationDomRenderer2 extends DefaultDomRenderer2 {\n  /**\n   * @param {?} eventManager\n   * @param {?} sharedStylesHost\n   * @param {?} component\n   * @param {?} appId\n   */\n  constructor(eventManager, sharedStylesHost, component, appId) {\n    super(eventManager);\n    this.component = component;\n    /** @type {?} */\n\n    const styles = flattenStyles(appId + '-' + component.id, component.styles, []);\n    sharedStylesHost.addStyles(styles);\n    this.contentAttr = shimContentAttribute(appId + '-' + component.id);\n    this.hostAttr = shimHostAttribute(appId + '-' + component.id);\n  }\n  /**\n   * @param {?} element\n   * @return {?}\n   */\n\n\n  applyToHost(element) {\n    super.setAttribute(element, this.hostAttr, '');\n  }\n  /**\n   * @param {?} parent\n   * @param {?} name\n   * @return {?}\n   */\n\n\n  createElement(parent, name) {\n    /** @type {?} */\n    const el = super.createElement(parent, name);\n    super.setAttribute(el, this.contentAttr, '');\n    return el;\n  }\n\n}\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  EmulatedEncapsulationDomRenderer2.prototype.contentAttr;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  EmulatedEncapsulationDomRenderer2.prototype.hostAttr;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  EmulatedEncapsulationDomRenderer2.prototype.component;\n}\n\nclass ShadowDomRenderer extends DefaultDomRenderer2 {\n  /**\n   * @param {?} eventManager\n   * @param {?} sharedStylesHost\n   * @param {?} hostEl\n   * @param {?} component\n   */\n  constructor(eventManager, sharedStylesHost, hostEl, component) {\n    super(eventManager);\n    this.sharedStylesHost = sharedStylesHost;\n    this.hostEl = hostEl;\n    this.component = component;\n\n    if (component.encapsulation === ViewEncapsulation.ShadowDom) {\n      this.shadowRoot =\n      /** @type {?} */\n      hostEl.attachShadow({\n        mode: 'open'\n      });\n    } else {\n      this.shadowRoot =\n      /** @type {?} */\n      hostEl.createShadowRoot();\n    }\n\n    this.sharedStylesHost.addHost(this.shadowRoot);\n    /** @type {?} */\n\n    const styles = flattenStyles(component.id, component.styles, []);\n\n    for (let i = 0; i < styles.length; i++) {\n      /** @type {?} */\n      const styleEl = document.createElement('style');\n      styleEl.textContent = styles[i];\n      this.shadowRoot.appendChild(styleEl);\n    }\n  }\n  /**\n   * @private\n   * @param {?} node\n   * @return {?}\n   */\n\n\n  nodeOrShadowRoot(node) {\n    return node === this.hostEl ? this.shadowRoot : node;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  destroy() {\n    this.sharedStylesHost.removeHost(this.shadowRoot);\n  }\n  /**\n   * @param {?} parent\n   * @param {?} newChild\n   * @return {?}\n   */\n\n\n  appendChild(parent, newChild) {\n    return super.appendChild(this.nodeOrShadowRoot(parent), newChild);\n  }\n  /**\n   * @param {?} parent\n   * @param {?} newChild\n   * @param {?} refChild\n   * @return {?}\n   */\n\n\n  insertBefore(parent, newChild, refChild) {\n    return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);\n  }\n  /**\n   * @param {?} parent\n   * @param {?} oldChild\n   * @return {?}\n   */\n\n\n  removeChild(parent, oldChild) {\n    return super.removeChild(this.nodeOrShadowRoot(parent), oldChild);\n  }\n  /**\n   * @param {?} node\n   * @return {?}\n   */\n\n\n  parentNode(node) {\n    return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));\n  }\n\n}\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  ShadowDomRenderer.prototype.shadowRoot;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ShadowDomRenderer.prototype.sharedStylesHost;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ShadowDomRenderer.prototype.hostEl;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  ShadowDomRenderer.prototype.component;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/dom/events/dom_events.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet DomEventsPlugin = /*#__PURE__*/(() => {\n  class DomEventsPlugin extends EventManagerPlugin {\n    /**\n     * @param {?} doc\n     */\n    constructor(doc) {\n      super(doc);\n    } // This plugin should come last in the list of plugins, because it accepts all\n    // events.\n\n    /**\n     * @param {?} eventName\n     * @return {?}\n     */\n\n\n    supports(eventName) {\n      return true;\n    }\n    /**\n     * @param {?} element\n     * @param {?} eventName\n     * @param {?} handler\n     * @return {?}\n     */\n\n\n    addEventListener(element, eventName, handler) {\n      element.addEventListener(eventName,\n      /** @type {?} */\n      handler, false);\n      return (\n        /**\n        * @return {?}\n        */\n        () => this.removeEventListener(element, eventName,\n        /** @type {?} */\n        handler)\n      );\n    }\n    /**\n     * @param {?} target\n     * @param {?} eventName\n     * @param {?} callback\n     * @return {?}\n     */\n\n\n    removeEventListener(target, eventName, callback) {\n      return target.removeEventListener(eventName,\n      /** @type {?} */\n      callback);\n    }\n\n  }\n\n  DomEventsPlugin.ɵfac = function DomEventsPlugin_Factory(t) {\n    return new (t || DomEventsPlugin)(ɵngcc0.ɵɵinject(DOCUMENT));\n  };\n\n  DomEventsPlugin.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: DomEventsPlugin,\n    factory: DomEventsPlugin.ɵfac\n  });\n  /** @nocollapse */\n\n  return DomEventsPlugin;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/dom/events/hammer_gestures.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Supported HammerJS recognizer event names.\n * @type {?}\n */\n\n\nconst EVENT_NAMES = {\n  // pan\n  'pan': true,\n  'panstart': true,\n  'panmove': true,\n  'panend': true,\n  'pancancel': true,\n  'panleft': true,\n  'panright': true,\n  'panup': true,\n  'pandown': true,\n  // pinch\n  'pinch': true,\n  'pinchstart': true,\n  'pinchmove': true,\n  'pinchend': true,\n  'pinchcancel': true,\n  'pinchin': true,\n  'pinchout': true,\n  // press\n  'press': true,\n  'pressup': true,\n  // rotate\n  'rotate': true,\n  'rotatestart': true,\n  'rotatemove': true,\n  'rotateend': true,\n  'rotatecancel': true,\n  // swipe\n  'swipe': true,\n  'swipeleft': true,\n  'swiperight': true,\n  'swipeup': true,\n  'swipedown': true,\n  // tap\n  'tap': true\n};\n/**\n * DI token for providing [HammerJS](http://hammerjs.github.io/) support to Angular.\n * @see `HammerGestureConfig`\n *\n * \\@ngModule HammerModule\n * \\@publicApi\n * @type {?}\n */\n\nconst HAMMER_GESTURE_CONFIG = /*#__PURE__*/new InjectionToken('HammerGestureConfig');\n/**\n * Injection token used to provide a {\\@link HammerLoader} to Angular.\n *\n * \\@publicApi\n * @type {?}\n */\n\nconst HAMMER_LOADER = /*#__PURE__*/new InjectionToken('HammerLoader');\n/**\n * @record\n */\n\nfunction HammerInstance() {}\n\nif (false) {\n  /**\n   * @param {?} eventName\n   * @param {?=} callback\n   * @return {?}\n   */\n  HammerInstance.prototype.on = function (eventName, callback) {};\n  /**\n   * @param {?} eventName\n   * @param {?=} callback\n   * @return {?}\n   */\n\n\n  HammerInstance.prototype.off = function (eventName, callback) {};\n  /**\n   * @return {?}\n   */\n\n\n  HammerInstance.prototype.destroy = function () {};\n}\n/**\n * An injectable [HammerJS Manager](http://hammerjs.github.io/api/#hammer.manager)\n * for gesture recognition. Configures specific event recognition.\n * \\@publicApi\n */\n\n\nlet HammerGestureConfig = /*#__PURE__*/(() => {\n  class HammerGestureConfig {\n    constructor() {\n      /**\n       * A set of supported event names for gestures to be used in Angular.\n       * Angular supports all built-in recognizers, as listed in\n       * [HammerJS documentation](http://hammerjs.github.io/).\n       */\n      this.events = [];\n      /**\n       * Maps gesture event names to a set of configuration options\n       * that specify overrides to the default values for specific properties.\n       *\n       * The key is a supported event name to be configured,\n       * and the options object contains a set of properties, with override values\n       * to be applied to the named recognizer event.\n       * For example, to disable recognition of the rotate event, specify\n       *  `{\"rotate\": {\"enable\": false}}`.\n       *\n       * Properties that are not present take the HammerJS default values.\n       * For information about which properties are supported for which events,\n       * and their allowed and default values, see\n       * [HammerJS documentation](http://hammerjs.github.io/).\n       *\n       */\n\n      this.overrides = {};\n    }\n    /**\n     * Creates a [HammerJS Manager](http://hammerjs.github.io/api/#hammer.manager)\n     * and attaches it to a given HTML element.\n     * @param {?} element The element that will recognize gestures.\n     * @return {?} A HammerJS event-manager object.\n     */\n\n\n    buildHammer(element) {\n      /** @type {?} */\n      const mc = new\n      /** @type {?} */\n      Hammer(element, this.options);\n      mc.get('pinch').set({\n        enable: true\n      });\n      mc.get('rotate').set({\n        enable: true\n      });\n\n      for (const eventName in this.overrides) {\n        mc.get(eventName).set(this.overrides[eventName]);\n      }\n\n      return mc;\n    }\n\n  }\n\n  HammerGestureConfig.ɵfac = function HammerGestureConfig_Factory(t) {\n    return new (t || HammerGestureConfig)();\n  };\n\n  HammerGestureConfig.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: HammerGestureConfig,\n    factory: HammerGestureConfig.ɵfac\n  });\n  return HammerGestureConfig;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * A set of supported event names for gestures to be used in Angular.\n   * Angular supports all built-in recognizers, as listed in\n   * [HammerJS documentation](http://hammerjs.github.io/).\n   * @type {?}\n   */\n  HammerGestureConfig.prototype.events;\n  /**\n   * Maps gesture event names to a set of configuration options\n   * that specify overrides to the default values for specific properties.\n   *\n   * The key is a supported event name to be configured,\n   * and the options object contains a set of properties, with override values\n   * to be applied to the named recognizer event.\n   * For example, to disable recognition of the rotate event, specify\n   *  `{\"rotate\": {\"enable\": false}}`.\n   *\n   * Properties that are not present take the HammerJS default values.\n   * For information about which properties are supported for which events,\n   * and their allowed and default values, see\n   * [HammerJS documentation](http://hammerjs.github.io/).\n   *\n   * @type {?}\n   */\n\n  HammerGestureConfig.prototype.overrides;\n  /**\n   * Properties whose default values can be overridden for a given event.\n   * Different sets of properties apply to different events.\n   * For information about which properties are supported for which events,\n   * and their allowed and default values, see\n   * [HammerJS documentation](http://hammerjs.github.io/).\n   * @type {?}\n   */\n\n  HammerGestureConfig.prototype.options;\n}\n/**\n * Event plugin that adds Hammer support to an application.\n *\n * \\@ngModule HammerModule\n */\n\n\nlet HammerGesturesPlugin = /*#__PURE__*/(() => {\n  class HammerGesturesPlugin extends EventManagerPlugin {\n    /**\n     * @param {?} doc\n     * @param {?} _config\n     * @param {?} console\n     * @param {?=} loader\n     */\n    constructor(doc, _config, console, loader) {\n      super(doc);\n      this._config = _config;\n      this.console = console;\n      this.loader = loader;\n    }\n    /**\n     * @param {?} eventName\n     * @return {?}\n     */\n\n\n    supports(eventName) {\n      if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {\n        return false;\n      }\n\n      if (!\n      /** @type {?} */\n      window.Hammer && !this.loader) {\n        this.console.warn(`The \"${eventName}\" event cannot be bound because Hammer.JS is not ` + `loaded and no custom loader has been specified.`);\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * @param {?} element\n     * @param {?} eventName\n     * @param {?} handler\n     * @return {?}\n     */\n\n\n    addEventListener(element, eventName, handler) {\n      /** @type {?} */\n      const zone = this.manager.getZone();\n      eventName = eventName.toLowerCase(); // If Hammer is not present but a loader is specified, we defer adding the event listener\n      // until Hammer is loaded.\n\n      if (!\n      /** @type {?} */\n      window.Hammer && this.loader) {\n        // This `addEventListener` method returns a function to remove the added listener.\n        // Until Hammer is loaded, the returned function needs to *cancel* the registration rather\n        // than remove anything.\n\n        /** @type {?} */\n        let cancelRegistration = false;\n        /** @type {?} */\n\n        let deregister =\n        /**\n        * @return {?}\n        */\n        () => {\n          cancelRegistration = true;\n        };\n\n        this.loader().then(\n        /**\n        * @return {?}\n        */\n        () => {\n          // If Hammer isn't actually loaded when the custom loader resolves, give up.\n          if (!\n          /** @type {?} */\n          window.Hammer) {\n            this.console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);\n\n            deregister =\n            /**\n            * @return {?}\n            */\n            () => {};\n\n            return;\n          }\n\n          if (!cancelRegistration) {\n            // Now that Hammer is loaded and the listener is being loaded for real,\n            // the deregistration function changes from canceling registration to removal.\n            deregister = this.addEventListener(element, eventName, handler);\n          }\n        }).catch(\n        /**\n        * @return {?}\n        */\n        () => {\n          this.console.warn(`The \"${eventName}\" event cannot be bound because the custom ` + `Hammer.JS loader failed.`);\n\n          deregister =\n          /**\n          * @return {?}\n          */\n          () => {};\n        }); // Return a function that *executes* `deregister` (and not `deregister` itself) so that we\n        // can change the behavior of `deregister` once the listener is added. Using a closure in\n        // this way allows us to avoid any additional data structures to track listener removal.\n\n        return (\n          /**\n          * @return {?}\n          */\n          () => {\n            deregister();\n          }\n        );\n      }\n\n      return zone.runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      () => {\n        // Creating the manager bind events, must be done outside of angular\n\n        /** @type {?} */\n        const mc = this._config.buildHammer(element);\n        /** @type {?} */\n\n\n        const callback =\n        /**\n        * @param {?} eventObj\n        * @return {?}\n        */\n        function (eventObj) {\n          zone.runGuarded(\n          /**\n          * @return {?}\n          */\n          function () {\n            handler(eventObj);\n          });\n        };\n\n        mc.on(eventName, callback);\n        return (\n          /**\n          * @return {?}\n          */\n          () => {\n            mc.off(eventName, callback); // destroy mc to prevent memory leak\n\n            if (typeof mc.destroy === 'function') {\n              mc.destroy();\n            }\n          }\n        );\n      });\n    }\n    /**\n     * @param {?} eventName\n     * @return {?}\n     */\n\n\n    isCustomEvent(eventName) {\n      return this._config.events.indexOf(eventName) > -1;\n    }\n\n  }\n\n  HammerGesturesPlugin.ɵfac = function HammerGesturesPlugin_Factory(t) {\n    return new (t || HammerGesturesPlugin)(ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(HAMMER_GESTURE_CONFIG), ɵngcc0.ɵɵinject(ɵngcc0.ɵConsole), ɵngcc0.ɵɵinject(HAMMER_LOADER, 8));\n  };\n\n  HammerGesturesPlugin.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: HammerGesturesPlugin,\n    factory: HammerGesturesPlugin.ɵfac\n  });\n  /** @nocollapse */\n\n  return HammerGesturesPlugin;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  HammerGesturesPlugin.prototype._config;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  HammerGesturesPlugin.prototype.console;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  HammerGesturesPlugin.prototype.loader;\n}\n/**\n * In Ivy, support for Hammer gestures is optional, so applications must\n * import the `HammerModule` at root to turn on support. This means that\n * Hammer-specific code can be tree-shaken away if not needed.\n * @type {?}\n */\n\n\nconst HAMMER_PROVIDERS__POST_R3__ = [];\n/**\n * In View Engine, support for Hammer gestures is built-in by default.\n * @type {?}\n */\n\nconst HAMMER_PROVIDERS__PRE_R3__ = [{\n  provide: EVENT_MANAGER_PLUGINS,\n  useClass: HammerGesturesPlugin,\n  multi: true,\n  deps: [DOCUMENT, HAMMER_GESTURE_CONFIG, ɵConsole, [/*#__PURE__*/new Optional(), HAMMER_LOADER]]\n}, {\n  provide: HAMMER_GESTURE_CONFIG,\n  useClass: HammerGestureConfig,\n  deps: []\n}];\n/** @type {?} */\n\nconst HAMMER_PROVIDERS = HAMMER_PROVIDERS__PRE_R3__;\n/**\n * Adds support for HammerJS.\n *\n * Import this module at the root of your application so that Angular can work with\n * HammerJS to detect gesture events.\n *\n * Note that applications still need to include the HammerJS script itself. This module\n * simply sets up the coordination layer between HammerJS and Angular's EventManager.\n *\n * \\@publicApi\n */\n\nlet HammerModule = /*#__PURE__*/(() => {\n  class HammerModule {}\n\n  HammerModule.ɵfac = function HammerModule_Factory(t) {\n    return new (t || HammerModule)();\n  };\n\n  HammerModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: HammerModule\n  });\n  HammerModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: HAMMER_PROVIDERS__PRE_R3__\n  });\n  return HammerModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/dom/events/key_events.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Defines supported modifiers for key events.\n * @type {?}\n */\n\n\nconst MODIFIER_KEYS = ['alt', 'control', 'meta', 'shift'];\n/** @type {?} */\n\nconst DOM_KEY_LOCATION_NUMPAD = 3; // Map to convert some key or keyIdentifier values to what will be returned by getEventKey\n\n/** @type {?} */\n\nconst _keyMap = {\n  // The following values are here for cross-browser compatibility and to match the W3C standard\n  // cf http://www.w3.org/TR/DOM-Level-3-Events-key/\n  '\\b': 'Backspace',\n  '\\t': 'Tab',\n  '\\x7F': 'Delete',\n  '\\x1B': 'Escape',\n  'Del': 'Delete',\n  'Esc': 'Escape',\n  'Left': 'ArrowLeft',\n  'Right': 'ArrowRight',\n  'Up': 'ArrowUp',\n  'Down': 'ArrowDown',\n  'Menu': 'ContextMenu',\n  'Scroll': 'ScrollLock',\n  'Win': 'OS'\n}; // There is a bug in Chrome for numeric keypad keys:\n// https://code.google.com/p/chromium/issues/detail?id=155654\n// 1, 2, 3 ... are reported as A, B, C ...\n\n/** @type {?} */\n\nconst _chromeNumKeyPadMap = {\n  'A': '1',\n  'B': '2',\n  'C': '3',\n  'D': '4',\n  'E': '5',\n  'F': '6',\n  'G': '7',\n  'H': '8',\n  'I': '9',\n  'J': '*',\n  'K': '+',\n  'M': '-',\n  'N': '.',\n  'O': '/',\n  '\\x60': '0',\n  '\\x90': 'NumLock'\n};\n\nconst ɵ0$3 =\n/**\n* @param {?} event\n* @return {?}\n*/\nevent => event.altKey,\n      ɵ1 =\n/**\n* @param {?} event\n* @return {?}\n*/\nevent => event.ctrlKey,\n      ɵ2 =\n/**\n* @param {?} event\n* @return {?}\n*/\nevent => event.metaKey,\n      ɵ3 =\n/**\n* @param {?} event\n* @return {?}\n*/\nevent => event.shiftKey;\n/**\n * Retrieves modifiers from key-event objects.\n * @type {?}\n */\n\n\nconst MODIFIER_KEY_GETTERS = {\n  'alt': ɵ0$3,\n  'control': ɵ1,\n  'meta': ɵ2,\n  'shift': ɵ3\n};\n/**\n * \\@publicApi\n * A browser plug-in that provides support for handling of key events in Angular.\n */\n\nlet KeyEventsPlugin = /*#__PURE__*/(() => {\n  class KeyEventsPlugin extends EventManagerPlugin {\n    /**\n     * Initializes an instance of the browser plug-in.\n     * @param {?} doc The document in which key events will be detected.\n     */\n    constructor(doc) {\n      super(doc);\n    }\n    /**\n     * Reports whether a named key event is supported.\n     * @param {?} eventName The event name to query.\n     * @return {?} True if the named key event is supported.\n     */\n\n\n    supports(eventName) {\n      return KeyEventsPlugin.parseEventName(eventName) != null;\n    }\n    /**\n     * Registers a handler for a specific element and key event.\n     * @param {?} element The HTML element to receive event notifications.\n     * @param {?} eventName The name of the key event to listen for.\n     * @param {?} handler A function to call when the notification occurs. Receives the\n     * event object as an argument.\n     * @return {?} The key event that was registered.\n     */\n\n\n    addEventListener(element, eventName, handler) {\n      /** @type {?} */\n      const parsedEvent =\n      /** @type {?} */\n      KeyEventsPlugin.parseEventName(eventName);\n      /** @type {?} */\n\n      const outsideHandler = KeyEventsPlugin.eventCallback(parsedEvent['fullKey'], handler, this.manager.getZone());\n      return this.manager.getZone().runOutsideAngular(\n      /**\n      * @return {?}\n      */\n      () => {\n        return ɵgetDOM().onAndCancel(element, parsedEvent['domEventName'], outsideHandler);\n      });\n    }\n    /**\n     * @param {?} eventName\n     * @return {?}\n     */\n\n\n    static parseEventName(eventName) {\n      /** @type {?} */\n      const parts = eventName.toLowerCase().split('.');\n      /** @type {?} */\n\n      const domEventName = parts.shift();\n\n      if (parts.length === 0 || !(domEventName === 'keydown' || domEventName === 'keyup')) {\n        return null;\n      }\n      /** @type {?} */\n\n\n      const key = KeyEventsPlugin._normalizeKey(\n      /** @type {?} */\n      parts.pop());\n      /** @type {?} */\n\n\n      let fullKey = '';\n      MODIFIER_KEYS.forEach(\n      /**\n      * @param {?} modifierName\n      * @return {?}\n      */\n      modifierName => {\n        /** @type {?} */\n        const index = parts.indexOf(modifierName);\n\n        if (index > -1) {\n          parts.splice(index, 1);\n          fullKey += modifierName + '.';\n        }\n      });\n      fullKey += key;\n\n      if (parts.length != 0 || key.length === 0) {\n        // returning null instead of throwing to let another plugin process the event\n        return null;\n      }\n      /** @type {?} */\n\n\n      const result = {};\n      result['domEventName'] = domEventName;\n      result['fullKey'] = fullKey;\n      return result;\n    }\n    /**\n     * @param {?} event\n     * @return {?}\n     */\n\n\n    static getEventFullKey(event) {\n      /** @type {?} */\n      let fullKey = '';\n      /** @type {?} */\n\n      let key = getEventKey(event);\n      key = key.toLowerCase();\n\n      if (key === ' ') {\n        key = 'space'; // for readability\n      } else if (key === '.') {\n        key = 'dot'; // because '.' is used as a separator in event names\n      }\n\n      MODIFIER_KEYS.forEach(\n      /**\n      * @param {?} modifierName\n      * @return {?}\n      */\n      modifierName => {\n        if (modifierName != key) {\n          /** @type {?} */\n          const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];\n\n          if (modifierGetter(event)) {\n            fullKey += modifierName + '.';\n          }\n        }\n      });\n      fullKey += key;\n      return fullKey;\n    }\n    /**\n     * Configures a handler callback for a key event.\n     * @param {?} fullKey The event name that combines all simultaneous keystrokes.\n     * @param {?} handler The function that responds to the key event.\n     * @param {?} zone The zone in which the event occurred.\n     * @return {?} A callback function.\n     */\n\n\n    static eventCallback(fullKey, handler, zone) {\n      return (\n        /**\n        * @param {?} event\n        * @return {?}\n        */\n        (event\n        /** TODO #9100 */\n        ) => {\n          if (KeyEventsPlugin.getEventFullKey(event) === fullKey) {\n            zone.runGuarded(\n            /**\n            * @return {?}\n            */\n            () => handler(event));\n          }\n        }\n      );\n    }\n    /**\n     * \\@internal\n     * @param {?} keyName\n     * @return {?}\n     */\n\n\n    static _normalizeKey(keyName) {\n      // TODO: switch to a Map if the mapping grows too much\n      switch (keyName) {\n        case 'esc':\n          return 'escape';\n\n        default:\n          return keyName;\n      }\n    }\n\n  }\n\n  KeyEventsPlugin.ɵfac = function KeyEventsPlugin_Factory(t) {\n    return new (t || KeyEventsPlugin)(ɵngcc0.ɵɵinject(DOCUMENT));\n  };\n\n  KeyEventsPlugin.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: KeyEventsPlugin,\n    factory: KeyEventsPlugin.ɵfac\n  });\n  /** @nocollapse */\n\n  return KeyEventsPlugin;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @param {?} event\n * @return {?}\n */\n\n\nfunction getEventKey(event) {\n  /** @type {?} */\n  let key = event.key;\n\n  if (key == null) {\n    key = event.keyIdentifier; // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and\n    // Safari cf\n    // http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces\n\n    if (key == null) {\n      return 'Unidentified';\n    }\n\n    if (key.startsWith('U+')) {\n      key = String.fromCharCode(parseInt(key.substring(2), 16));\n\n      if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {\n        // There is a bug in Chrome for numeric keypad keys:\n        // https://code.google.com/p/chromium/issues/detail?id=155654\n        // 1, 2, 3 ... are reported as A, B, C ...\n        key =\n        /** @type {?} */\n        _chromeNumKeyPadMap[key];\n      }\n    }\n  }\n\n  return _keyMap[key] || key;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/security/dom_sanitization_service.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Marker interface for a value that's safe to use in a particular context.\n *\n * \\@publicApi\n * @record\n */\n\n\nfunction SafeValue() {}\n/**\n * Marker interface for a value that's safe to use as HTML.\n *\n * \\@publicApi\n * @record\n */\n\n\nfunction SafeHtml() {}\n/**\n * Marker interface for a value that's safe to use as style (CSS).\n *\n * \\@publicApi\n * @record\n */\n\n\nfunction SafeStyle() {}\n/**\n * Marker interface for a value that's safe to use as JavaScript.\n *\n * \\@publicApi\n * @record\n */\n\n\nfunction SafeScript() {}\n/**\n * Marker interface for a value that's safe to use as a URL linking to a document.\n *\n * \\@publicApi\n * @record\n */\n\n\nfunction SafeUrl() {}\n/**\n * Marker interface for a value that's safe to use as a URL to load executable code from.\n *\n * \\@publicApi\n * @record\n */\n\n\nfunction SafeResourceUrl() {}\n/**\n * DomSanitizer helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing\n * values to be safe to use in the different DOM contexts.\n *\n * For example, when binding a URL in an `<a [href]=\"someValue\">` hyperlink, `someValue` will be\n * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on\n * the website.\n *\n * In specific situations, it might be necessary to disable sanitization, for example if the\n * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.\n * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`\n * methods, and then binding to that value from the template.\n *\n * These situations should be very rare, and extraordinary care must be taken to avoid creating a\n * Cross Site Scripting (XSS) security bug!\n *\n * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as\n * close as possible to the source of the value, to make it easy to verify no security bug is\n * created by its use.\n *\n * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that\n * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous\n * code. The sanitizer leaves safe values intact.\n *\n * \\@security Calling any of the `bypassSecurityTrust...` APIs disables Angular's built-in\n * sanitization for the value passed in. Carefully check and audit all values and code paths going\n * into this call. Make sure any user data is appropriately escaped for this security context.\n * For more detail, see the [Security Guide](http://g.co/ng/security).\n *\n * \\@publicApi\n * @abstract\n */\n\n\nlet DomSanitizer = /*#__PURE__*/(() => {\n  class DomSanitizer {}\n\n  DomSanitizer.ɵfac = function DomSanitizer_Factory(t) {\n    return new (t || DomSanitizer)();\n  };\n  /** @nocollapse */\n\n\n  DomSanitizer.ɵprov = ɵɵdefineInjectable({\n    factory: function DomSanitizer_Factory() {\n      return ɵɵinject(DomSanitizerImpl);\n    },\n    token: DomSanitizer,\n    providedIn: \"root\"\n  });\n  return DomSanitizer;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * Sanitizes a value for use in the given SecurityContext.\n   *\n   * If value is trusted for the context, this method will unwrap the contained safe value and use\n   * it directly. Otherwise, value will be sanitized to be safe in the given context, for example\n   * by replacing URLs that have an unsafe protocol part (such as `javascript:`). The implementation\n   * is responsible to make sure that the value can definitely be safely used in the given context.\n   * @abstract\n   * @param {?} context\n   * @param {?} value\n   * @return {?}\n   */\n  DomSanitizer.prototype.sanitize = function (context, value) {};\n  /**\n   * Bypass security and trust the given value to be safe HTML. Only use this when the bound HTML\n   * is unsafe (e.g. contains `<script>` tags) and the code should be executed. The sanitizer will\n   * leave safe HTML intact, so in most situations this method should not be used.\n   *\n   * **WARNING:** calling this method with untrusted user data exposes your application to XSS\n   * security risks!\n   * @abstract\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  DomSanitizer.prototype.bypassSecurityTrustHtml = function (value) {};\n  /**\n   * Bypass security and trust the given value to be safe style value (CSS).\n   *\n   * **WARNING:** calling this method with untrusted user data exposes your application to XSS\n   * security risks!\n   * @abstract\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  DomSanitizer.prototype.bypassSecurityTrustStyle = function (value) {};\n  /**\n   * Bypass security and trust the given value to be safe JavaScript.\n   *\n   * **WARNING:** calling this method with untrusted user data exposes your application to XSS\n   * security risks!\n   * @abstract\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  DomSanitizer.prototype.bypassSecurityTrustScript = function (value) {};\n  /**\n   * Bypass security and trust the given value to be a safe style URL, i.e. a value that can be used\n   * in hyperlinks or `<img src>`.\n   *\n   * **WARNING:** calling this method with untrusted user data exposes your application to XSS\n   * security risks!\n   * @abstract\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  DomSanitizer.prototype.bypassSecurityTrustUrl = function (value) {};\n  /**\n   * Bypass security and trust the given value to be a safe resource URL, i.e. a location that may\n   * be used to load executable code from, like `<script src>`, or `<iframe src>`.\n   *\n   * **WARNING:** calling this method with untrusted user data exposes your application to XSS\n   * security risks!\n   * @abstract\n   * @param {?} value\n   * @return {?}\n   */\n\n\n  DomSanitizer.prototype.bypassSecurityTrustResourceUrl = function (value) {};\n}\n/**\n * @param {?} injector\n * @return {?}\n */\n\n\nfunction domSanitizerImplFactory(injector) {\n  return new DomSanitizerImpl(injector.get(DOCUMENT));\n}\n\nlet DomSanitizerImpl = /*#__PURE__*/(() => {\n  class DomSanitizerImpl extends DomSanitizer {\n    /**\n     * @param {?} _doc\n     */\n    constructor(_doc) {\n      super();\n      this._doc = _doc;\n    }\n    /**\n     * @param {?} ctx\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    sanitize(ctx, value) {\n      if (value == null) return null;\n\n      switch (ctx) {\n        case SecurityContext.NONE:\n          return (\n            /** @type {?} */\n            value\n          );\n\n        case SecurityContext.HTML:\n          if (ɵallowSanitizationBypassAndThrow(value, \"HTML\"\n          /* Html */\n          )) {\n            return ɵunwrapSafeValue(value);\n          }\n\n          return ɵ_sanitizeHtml(this._doc, String(value));\n\n        case SecurityContext.STYLE:\n          if (ɵallowSanitizationBypassAndThrow(value, \"Style\"\n          /* Style */\n          )) {\n            return ɵunwrapSafeValue(value);\n          }\n\n          return ɵ_sanitizeStyle(\n          /** @type {?} */\n          value);\n\n        case SecurityContext.SCRIPT:\n          if (ɵallowSanitizationBypassAndThrow(value, \"Script\"\n          /* Script */\n          )) {\n            return ɵunwrapSafeValue(value);\n          }\n\n          throw new Error('unsafe value used in a script context');\n\n        case SecurityContext.URL:\n          /** @type {?} */\n          const type = ɵgetSanitizationBypassType(value);\n\n          if (ɵallowSanitizationBypassAndThrow(value, \"URL\"\n          /* Url */\n          )) {\n            return ɵunwrapSafeValue(value);\n          }\n\n          return ɵ_sanitizeUrl(String(value));\n\n        case SecurityContext.RESOURCE_URL:\n          if (ɵallowSanitizationBypassAndThrow(value, \"ResourceURL\"\n          /* ResourceUrl */\n          )) {\n            return ɵunwrapSafeValue(value);\n          }\n\n          throw new Error('unsafe value used in a resource URL context (see http://g.co/ng/security#xss)');\n\n        default:\n          throw new Error(`Unexpected SecurityContext ${ctx} (see http://g.co/ng/security#xss)`);\n      }\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    bypassSecurityTrustHtml(value) {\n      return ɵbypassSanitizationTrustHtml(value);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    bypassSecurityTrustStyle(value) {\n      return ɵbypassSanitizationTrustStyle(value);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    bypassSecurityTrustScript(value) {\n      return ɵbypassSanitizationTrustScript(value);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    bypassSecurityTrustUrl(value) {\n      return ɵbypassSanitizationTrustUrl(value);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    bypassSecurityTrustResourceUrl(value) {\n      return ɵbypassSanitizationTrustResourceUrl(value);\n    }\n\n  }\n\n  DomSanitizerImpl.ɵfac = function DomSanitizerImpl_Factory(t) {\n    return new (t || DomSanitizerImpl)(ɵngcc0.ɵɵinject(DOCUMENT));\n  };\n  /** @nocollapse */\n\n\n  /** @nocollapse */\n  DomSanitizerImpl.ɵprov = ɵɵdefineInjectable({\n    factory: function DomSanitizerImpl_Factory() {\n      return domSanitizerImplFactory(ɵɵinject(INJECTOR));\n    },\n    token: DomSanitizerImpl,\n    providedIn: \"root\"\n  });\n  return DomSanitizerImpl;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  DomSanitizerImpl.prototype._doc;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/browser.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @return {?}\n */\n\n\nfunction initDomAdapter() {\n  BrowserDomAdapter.makeCurrent();\n  BrowserGetTestability.init();\n}\n/**\n * @return {?}\n */\n\n\nfunction errorHandler() {\n  return new ErrorHandler();\n}\n/**\n * @return {?}\n */\n\n\nfunction _document() {\n  // Tell ivy about the global document\n  ɵsetDocument(document);\n  return document;\n}\n\nconst ɵ0$4 = ɵPLATFORM_BROWSER_ID;\n/** @type {?} */\n\nconst INTERNAL_BROWSER_PLATFORM_PROVIDERS = [{\n  provide: PLATFORM_ID,\n  useValue: ɵ0$4\n}, {\n  provide: PLATFORM_INITIALIZER,\n  useValue: initDomAdapter,\n  multi: true\n}, {\n  provide: DOCUMENT,\n  useFactory: _document,\n  deps: []\n}];\n/** @type {?} */\n\nconst BROWSER_SANITIZATION_PROVIDERS__PRE_R3__ = [{\n  provide: Sanitizer,\n  useExisting: DomSanitizer\n}, {\n  provide: DomSanitizer,\n  useClass: DomSanitizerImpl,\n  deps: [DOCUMENT]\n}];\n/** @type {?} */\n\nconst BROWSER_SANITIZATION_PROVIDERS__POST_R3__ = [];\n/**\n * \\@security Replacing built-in sanitization providers exposes the application to XSS risks.\n * Attacker-controlled data introduced by an unsanitized provider could expose your\n * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).\n * \\@publicApi\n * @type {?}\n */\n\nconst BROWSER_SANITIZATION_PROVIDERS = BROWSER_SANITIZATION_PROVIDERS__PRE_R3__;\n/**\n * \\@publicApi\n * @type {?}\n */\n\nconst platformBrowser = /*#__PURE__*/createPlatformFactory(platformCore, 'browser', INTERNAL_BROWSER_PLATFORM_PROVIDERS);\n/** @type {?} */\n\nconst BROWSER_MODULE_PROVIDERS = [BROWSER_SANITIZATION_PROVIDERS, {\n  provide: ɵINJECTOR_SCOPE,\n  useValue: 'root'\n}, {\n  provide: ErrorHandler,\n  useFactory: errorHandler,\n  deps: []\n}, {\n  provide: EVENT_MANAGER_PLUGINS,\n  useClass: DomEventsPlugin,\n  multi: true,\n  deps: [DOCUMENT, NgZone, PLATFORM_ID]\n}, {\n  provide: EVENT_MANAGER_PLUGINS,\n  useClass: KeyEventsPlugin,\n  multi: true,\n  deps: [DOCUMENT]\n}, HAMMER_PROVIDERS, {\n  provide: DomRendererFactory2,\n  useClass: DomRendererFactory2,\n  deps: [EventManager, DomSharedStylesHost, APP_ID]\n}, {\n  provide: RendererFactory2,\n  useExisting: DomRendererFactory2\n}, {\n  provide: SharedStylesHost,\n  useExisting: DomSharedStylesHost\n}, {\n  provide: DomSharedStylesHost,\n  useClass: DomSharedStylesHost,\n  deps: [DOCUMENT]\n}, {\n  provide: Testability,\n  useClass: Testability,\n  deps: [NgZone]\n}, {\n  provide: EventManager,\n  useClass: EventManager,\n  deps: [EVENT_MANAGER_PLUGINS, NgZone]\n}, ELEMENT_PROBE_PROVIDERS];\n/**\n * Exports required infrastructure for all Angular apps.\n * Included by default in all Angular apps created with the CLI\n * `new` command.\n * Re-exports `CommonModule` and `ApplicationModule`, making their\n * exports and providers available to all apps.\n *\n * \\@publicApi\n */\n\nlet BrowserModule = /*#__PURE__*/(() => {\n  class BrowserModule {\n    /**\n     * @param {?} parentModule\n     */\n    constructor(parentModule) {\n      if (parentModule) {\n        throw new Error(`BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.`);\n      }\n    }\n    /**\n     * Configures a browser-based app to transition from a server-rendered app, if\n     * one is present on the page.\n     *\n     * @param {?} params An object containing an identifier for the app to transition.\n     * The ID must match between the client and server versions of the app.\n     * @return {?} The reconfigured `BrowserModule` to import into the app's root `AppModule`.\n     */\n\n\n    static withServerTransition(params) {\n      return {\n        ngModule: BrowserModule,\n        providers: [{\n          provide: APP_ID,\n          useValue: params.appId\n        }, {\n          provide: TRANSITION_ID,\n          useExisting: APP_ID\n        }, SERVER_TRANSITION_PROVIDERS]\n      };\n    }\n\n  }\n\n  BrowserModule.ɵfac = function BrowserModule_Factory(t) {\n    return new (t || BrowserModule)(ɵngcc0.ɵɵinject(BrowserModule, 12));\n  };\n\n  BrowserModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: BrowserModule\n  });\n  BrowserModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: BROWSER_MODULE_PROVIDERS,\n    imports: [CommonModule, ApplicationModule]\n  });\n  /** @nocollapse */\n\n  return BrowserModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(BrowserModule, {\n    exports: function () {\n      return [CommonModule, ApplicationModule];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/browser/meta.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Factory to create Meta service.\n * @return {?}\n */\n\n\nfunction createMeta() {\n  return new Meta(ɵɵinject(DOCUMENT));\n}\n/**\n * A service that can be used to get and add meta tags.\n *\n * \\@publicApi\n */\n\n\nlet Meta = /*#__PURE__*/(() => {\n  class Meta {\n    /**\n     * @param {?} _doc\n     */\n    constructor(_doc) {\n      this._doc = _doc;\n      this._dom = ɵgetDOM();\n    }\n    /**\n     * @param {?} tag\n     * @param {?=} forceCreation\n     * @return {?}\n     */\n\n\n    addTag(tag, forceCreation = false) {\n      if (!tag) return null;\n      return this._getOrCreateElement(tag, forceCreation);\n    }\n    /**\n     * @param {?} tags\n     * @param {?=} forceCreation\n     * @return {?}\n     */\n\n\n    addTags(tags, forceCreation = false) {\n      if (!tags) return [];\n      return tags.reduce(\n      /**\n      * @param {?} result\n      * @param {?} tag\n      * @return {?}\n      */\n      (result, tag) => {\n        if (tag) {\n          result.push(this._getOrCreateElement(tag, forceCreation));\n        }\n\n        return result;\n      }, []);\n    }\n    /**\n     * @param {?} attrSelector\n     * @return {?}\n     */\n\n\n    getTag(attrSelector) {\n      if (!attrSelector) return null;\n      return this._doc.querySelector(`meta[${attrSelector}]`) || null;\n    }\n    /**\n     * @param {?} attrSelector\n     * @return {?}\n     */\n\n\n    getTags(attrSelector) {\n      if (!attrSelector) return [];\n      /** @type {?} */\n\n      const list\n      /*NodeList*/\n      = this._doc.querySelectorAll(`meta[${attrSelector}]`);\n\n      return list ? [].slice.call(list) : [];\n    }\n    /**\n     * @param {?} tag\n     * @param {?=} selector\n     * @return {?}\n     */\n\n\n    updateTag(tag, selector) {\n      if (!tag) return null;\n      selector = selector || this._parseSelector(tag);\n      /** @type {?} */\n\n      const meta =\n      /** @type {?} */\n      this.getTag(selector);\n\n      if (meta) {\n        return this._setMetaElementAttributes(tag, meta);\n      }\n\n      return this._getOrCreateElement(tag, true);\n    }\n    /**\n     * @param {?} attrSelector\n     * @return {?}\n     */\n\n\n    removeTag(attrSelector) {\n      this.removeTagElement(\n      /** @type {?} */\n      this.getTag(attrSelector));\n    }\n    /**\n     * @param {?} meta\n     * @return {?}\n     */\n\n\n    removeTagElement(meta) {\n      if (meta) {\n        this._dom.remove(meta);\n      }\n    }\n    /**\n     * @private\n     * @param {?} meta\n     * @param {?=} forceCreation\n     * @return {?}\n     */\n\n\n    _getOrCreateElement(meta, forceCreation = false) {\n      if (!forceCreation) {\n        /** @type {?} */\n        const selector = this._parseSelector(meta);\n        /** @type {?} */\n\n\n        const elem =\n        /** @type {?} */\n        this.getTag(selector); // It's allowed to have multiple elements with the same name so it's not enough to\n        // just check that element with the same name already present on the page. We also need to\n        // check if element has tag attributes\n\n        if (elem && this._containsAttributes(meta, elem)) return elem;\n      }\n      /** @type {?} */\n\n\n      const element =\n      /** @type {?} */\n      this._dom.createElement('meta');\n\n      this._setMetaElementAttributes(meta, element);\n      /** @type {?} */\n\n\n      const head = this._doc.getElementsByTagName('head')[0];\n\n      head.appendChild(element);\n      return element;\n    }\n    /**\n     * @private\n     * @param {?} tag\n     * @param {?} el\n     * @return {?}\n     */\n\n\n    _setMetaElementAttributes(tag, el) {\n      Object.keys(tag).forEach(\n      /**\n      * @param {?} prop\n      * @return {?}\n      */\n      prop => el.setAttribute(prop, tag[prop]));\n      return el;\n    }\n    /**\n     * @private\n     * @param {?} tag\n     * @return {?}\n     */\n\n\n    _parseSelector(tag) {\n      /** @type {?} */\n      const attr = tag.name ? 'name' : 'property';\n      return `${attr}=\"${tag[attr]}\"`;\n    }\n    /**\n     * @private\n     * @param {?} tag\n     * @param {?} elem\n     * @return {?}\n     */\n\n\n    _containsAttributes(tag, elem) {\n      return Object.keys(tag).every(\n      /**\n      * @param {?} key\n      * @return {?}\n      */\n      key => elem.getAttribute(key) === tag[key]);\n    }\n\n  }\n\n  Meta.ɵfac = function Meta_Factory(t) {\n    return new (t || Meta)(ɵngcc0.ɵɵinject(DOCUMENT));\n  };\n  /** @nocollapse */\n\n\n  /** @nocollapse */\n  Meta.ɵprov = ɵɵdefineInjectable({\n    factory: createMeta,\n    token: Meta,\n    providedIn: \"root\"\n  });\n  return Meta;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  Meta.prototype._dom;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  Meta.prototype._doc;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/browser/title.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Factory to create Title service.\n * @return {?}\n */\n\n\nfunction createTitle() {\n  return new Title(ɵɵinject(DOCUMENT));\n}\n/**\n * A service that can be used to get and set the title of a current HTML document.\n *\n * Since an Angular application can't be bootstrapped on the entire HTML document (`<html>` tag)\n * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements\n * (representing the `<title>` tag). Instead, this service can be used to set and get the current\n * title value.\n *\n * \\@publicApi\n */\n\n\nlet Title = /*#__PURE__*/(() => {\n  class Title {\n    /**\n     * @param {?} _doc\n     */\n    constructor(_doc) {\n      this._doc = _doc;\n    }\n    /**\n     * Get the title of the current HTML document.\n     * @return {?}\n     */\n\n\n    getTitle() {\n      return this._doc.title;\n    }\n    /**\n     * Set the title of the current HTML document.\n     * @param {?} newTitle\n     * @return {?}\n     */\n\n\n    setTitle(newTitle) {\n      this._doc.title = newTitle || '';\n    }\n\n  }\n\n  Title.ɵfac = function Title_Factory(t) {\n    return new (t || Title)(ɵngcc0.ɵɵinject(DOCUMENT));\n  };\n  /** @nocollapse */\n\n\n  /** @nocollapse */\n  Title.ɵprov = ɵɵdefineInjectable({\n    factory: createTitle,\n    token: Title,\n    providedIn: \"root\"\n  });\n  return Title;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  Title.prototype._doc;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/browser/tools/browser.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** @type {?} */\n\n\nconst win = typeof window !== 'undefined' && window ||\n/** @type {?} */\n{};\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/browser/tools/common_tools.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nclass ChangeDetectionPerfRecord {\n  /**\n   * @param {?} msPerTick\n   * @param {?} numTicks\n   */\n  constructor(msPerTick, numTicks) {\n    this.msPerTick = msPerTick;\n    this.numTicks = numTicks;\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  ChangeDetectionPerfRecord.prototype.msPerTick;\n  /** @type {?} */\n\n  ChangeDetectionPerfRecord.prototype.numTicks;\n}\n/**\n * Entry point for all Angular profiling-related debug tools. This object\n * corresponds to the `ng.profiler` in the dev console.\n */\n\n\nclass AngularProfiler {\n  /**\n   * @param {?} ref\n   */\n  constructor(ref) {\n    this.appRef = ref.injector.get(ApplicationRef);\n  } // tslint:disable:no-console\n\n  /**\n   * Exercises change detection in a loop and then prints the average amount of\n   * time in milliseconds how long a single round of change detection takes for\n   * the current state of the UI. It runs a minimum of 5 rounds for a minimum\n   * of 500 milliseconds.\n   *\n   * Optionally, a user may pass a `config` parameter containing a map of\n   * options. Supported options are:\n   *\n   * `record` (boolean) - causes the profiler to record a CPU profile while\n   * it exercises the change detector. Example:\n   *\n   * ```\n   * ng.profiler.timeChangeDetection({record: true})\n   * ```\n   * @param {?} config\n   * @return {?}\n   */\n\n\n  timeChangeDetection(config) {\n    /** @type {?} */\n    const record = config && config['record'];\n    /** @type {?} */\n\n    const profileName = 'Change Detection'; // Profiler is not available in Android browsers, nor in IE 9 without dev tools opened\n\n    /** @type {?} */\n\n    const isProfilerAvailable = win.console.profile != null;\n\n    if (record && isProfilerAvailable) {\n      win.console.profile(profileName);\n    }\n    /** @type {?} */\n\n\n    const start = ɵgetDOM().performanceNow();\n    /** @type {?} */\n\n    let numTicks = 0;\n\n    while (numTicks < 5 || ɵgetDOM().performanceNow() - start < 500) {\n      this.appRef.tick();\n      numTicks++;\n    }\n    /** @type {?} */\n\n\n    const end = ɵgetDOM().performanceNow();\n\n    if (record && isProfilerAvailable) {\n      win.console.profileEnd(profileName);\n    }\n    /** @type {?} */\n\n\n    const msPerTick = (end - start) / numTicks;\n    win.console.log(`ran ${numTicks} change detection cycles`);\n    win.console.log(`${msPerTick.toFixed(2)} ms per check`);\n    return new ChangeDetectionPerfRecord(msPerTick, numTicks);\n  }\n\n}\n\nif (false) {\n  /** @type {?} */\n  AngularProfiler.prototype.appRef;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/browser/tools/tools.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst PROFILER_GLOBAL_NAME = 'profiler';\n/**\n * Enabled Angular debug tools that are accessible via your browser's\n * developer console.\n *\n * Usage:\n *\n * 1. Open developer console (e.g. in Chrome Ctrl + Shift + j)\n * 1. Type `ng.` (usually the console will show auto-complete suggestion)\n * 1. Try the change detection profiler `ng.profiler.timeChangeDetection()`\n *    then hit Enter.\n *\n * \\@publicApi\n * @template T\n * @param {?} ref\n * @return {?}\n */\n\nfunction enableDebugTools(ref) {\n  exportNgVar(PROFILER_GLOBAL_NAME, new AngularProfiler(ref));\n  return ref;\n}\n/**\n * Disables Angular tools.\n *\n * \\@publicApi\n * @return {?}\n */\n\n\nfunction disableDebugTools() {\n  exportNgVar(PROFILER_GLOBAL_NAME, null);\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/browser/transfer_state.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} text\n * @return {?}\n */\n\n\nfunction escapeHtml(text) {\n  /** @type {?} */\n  const escapedText = {\n    '&': '&a;',\n    '\"': '&q;',\n    '\\'': '&s;',\n    '<': '&l;',\n    '>': '&g;'\n  };\n  return text.replace(/[&\"'<>]/g,\n  /**\n  * @param {?} s\n  * @return {?}\n  */\n  s => escapedText[s]);\n}\n/**\n * @param {?} text\n * @return {?}\n */\n\n\nfunction unescapeHtml(text) {\n  /** @type {?} */\n  const unescapedText = {\n    '&a;': '&',\n    '&q;': '\"',\n    '&s;': '\\'',\n    '&l;': '<',\n    '&g;': '>'\n  };\n  return text.replace(/&[^;]+;/g,\n  /**\n  * @param {?} s\n  * @return {?}\n  */\n  s => unescapedText[s]);\n}\n/**\n * Create a `StateKey<T>` that can be used to store value of type T with `TransferState`.\n *\n * Example:\n *\n * ```\n * const COUNTER_KEY = makeStateKey<number>('counter');\n * let value = 10;\n *\n * transferState.set(COUNTER_KEY, value);\n * ```\n *\n * \\@publicApi\n * @template T\n * @param {?} key\n * @return {?}\n */\n\n\nfunction makeStateKey(key) {\n  return (\n    /** @type {?} */\n    key\n  );\n}\n/**\n * A key value store that is transferred from the application on the server side to the application\n * on the client side.\n *\n * `TransferState` will be available as an injectable token. To use it import\n * `ServerTransferStateModule` on the server and `BrowserTransferStateModule` on the client.\n *\n * The values in the store are serialized/deserialized using JSON.stringify/JSON.parse. So only\n * boolean, number, string, null and non-class objects will be serialized and deserialzied in a\n * non-lossy manner.\n *\n * \\@publicApi\n */\n\n\nlet TransferState = /*#__PURE__*/(() => {\n  class TransferState {\n    constructor() {\n      this.store = {};\n      this.onSerializeCallbacks = {};\n    }\n    /**\n     * \\@internal\n     * @param {?} initState\n     * @return {?}\n     */\n\n\n    static init(initState) {\n      /** @type {?} */\n      const transferState = new TransferState();\n      transferState.store = initState;\n      return transferState;\n    }\n    /**\n     * Get the value corresponding to a key. Return `defaultValue` if key is not found.\n     * @template T\n     * @param {?} key\n     * @param {?} defaultValue\n     * @return {?}\n     */\n\n\n    get(key, defaultValue) {\n      return this.store[key] !== undefined ?\n      /** @type {?} */\n      this.store[key] : defaultValue;\n    }\n    /**\n     * Set the value corresponding to a key.\n     * @template T\n     * @param {?} key\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set(key, value) {\n      this.store[key] = value;\n    }\n    /**\n     * Remove a key from the store.\n     * @template T\n     * @param {?} key\n     * @return {?}\n     */\n\n\n    remove(key) {\n      delete this.store[key];\n    }\n    /**\n     * Test whether a key exists in the store.\n     * @template T\n     * @param {?} key\n     * @return {?}\n     */\n\n\n    hasKey(key) {\n      return this.store.hasOwnProperty(key);\n    }\n    /**\n     * Register a callback to provide the value for a key when `toJson` is called.\n     * @template T\n     * @param {?} key\n     * @param {?} callback\n     * @return {?}\n     */\n\n\n    onSerialize(key, callback) {\n      this.onSerializeCallbacks[key] = callback;\n    }\n    /**\n     * Serialize the current state of the store to JSON.\n     * @return {?}\n     */\n\n\n    toJson() {\n      // Call the onSerialize callbacks and put those values into the store.\n      for (const key in this.onSerializeCallbacks) {\n        if (this.onSerializeCallbacks.hasOwnProperty(key)) {\n          try {\n            this.store[key] = this.onSerializeCallbacks[key]();\n          } catch (e) {\n            console.warn('Exception in onSerialize callback: ', e);\n          }\n        }\n      }\n\n      return JSON.stringify(this.store);\n    }\n\n  }\n\n  TransferState.ɵfac = function TransferState_Factory(t) {\n    return new (t || TransferState)();\n  };\n\n  TransferState.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: TransferState,\n    factory: TransferState.ɵfac\n  });\n  return TransferState;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  TransferState.prototype.store;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  TransferState.prototype.onSerializeCallbacks;\n}\n/**\n * @param {?} doc\n * @param {?} appId\n * @return {?}\n */\n\n\nfunction initTransferState(doc, appId) {\n  // Locate the script tag with the JSON data transferred from the server.\n  // The id of the script tag is set to the Angular appId + 'state'.\n\n  /** @type {?} */\n  const script = doc.getElementById(appId + '-state');\n  /** @type {?} */\n\n  let initialState = {};\n\n  if (script && script.textContent) {\n    try {\n      initialState = JSON.parse(unescapeHtml(script.textContent));\n    } catch (e) {\n      console.warn('Exception while restoring TransferState for app ' + appId, e);\n    }\n  }\n\n  return TransferState.init(initialState);\n}\n/**\n * NgModule to install on the client side while using the `TransferState` to transfer state from\n * server to client.\n *\n * \\@publicApi\n */\n\n\nlet BrowserTransferStateModule = /*#__PURE__*/(() => {\n  class BrowserTransferStateModule {}\n\n  BrowserTransferStateModule.ɵfac = function BrowserTransferStateModule_Factory(t) {\n    return new (t || BrowserTransferStateModule)();\n  };\n\n  BrowserTransferStateModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: BrowserTransferStateModule\n  });\n  BrowserTransferStateModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [{\n      provide: TransferState,\n      useFactory: initTransferState,\n      deps: [DOCUMENT, APP_ID]\n    }]\n  });\n  return BrowserTransferStateModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/dom/debug/by.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Predicates for use with {\\@link DebugElement}'s query functions.\n *\n * \\@publicApi\n */\n\n\nclass By {\n  /**\n   * Match all nodes.\n   *\n   * \\@usageNotes\n   * ### Example\n   *\n   * {\\@example platform-browser/dom/debug/ts/by/by.ts region='by_all'}\n   * @return {?}\n   */\n  static all() {\n    return (\n      /**\n      * @return {?}\n      */\n      () => true\n    );\n  }\n  /**\n   * Match elements by the given CSS selector.\n   *\n   * \\@usageNotes\n   * ### Example\n   *\n   * {\\@example platform-browser/dom/debug/ts/by/by.ts region='by_css'}\n   * @param {?} selector\n   * @return {?}\n   */\n\n\n  static css(selector) {\n    return (\n      /**\n      * @param {?} debugElement\n      * @return {?}\n      */\n      debugElement => {\n        return debugElement.nativeElement != null ? elementMatches(debugElement.nativeElement, selector) : false;\n      }\n    );\n  }\n  /**\n   * Match nodes that have the given directive present.\n   *\n   * \\@usageNotes\n   * ### Example\n   *\n   * {\\@example platform-browser/dom/debug/ts/by/by.ts region='by_directive'}\n   * @param {?} type\n   * @return {?}\n   */\n\n\n  static directive(type) {\n    return (\n      /**\n      * @param {?} debugNode\n      * @return {?}\n      */\n      debugNode =>\n      /** @type {?} */\n      debugNode.providerTokens.indexOf(type) !== -1\n    );\n  }\n\n}\n/**\n * @param {?} n\n * @param {?} selector\n * @return {?}\n */\n\n\nfunction elementMatches(n, selector) {\n  if (ɵgetDOM().isElementNode(n)) {\n    return n.matches && n.matches(selector) || n.msMatchesSelector && n.msMatchesSelector(selector) || n.webkitMatchesSelector && n.webkitMatchesSelector(selector);\n  }\n\n  return false;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/private_export.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/version.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * \\@publicApi\n * @type {?}\n */\n\n\nconst VERSION = /*#__PURE__*/new Version('9.1.13');\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/src/platform-browser.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { BrowserModule, BrowserTransferStateModule, By, DomSanitizer, EVENT_MANAGER_PLUGINS, EventManager, HAMMER_GESTURE_CONFIG, HAMMER_LOADER, HammerGestureConfig, HammerModule, Meta, Title, TransferState, VERSION, disableDebugTools, enableDebugTools, makeStateKey, platformBrowser, BROWSER_SANITIZATION_PROVIDERS as ɵBROWSER_SANITIZATION_PROVIDERS, BROWSER_SANITIZATION_PROVIDERS__POST_R3__ as ɵBROWSER_SANITIZATION_PROVIDERS__POST_R3__, BrowserDomAdapter as ɵBrowserDomAdapter, BrowserGetTestability as ɵBrowserGetTestability, DomEventsPlugin as ɵDomEventsPlugin, DomRendererFactory2 as ɵDomRendererFactory2, DomSanitizerImpl as ɵDomSanitizerImpl, DomSharedStylesHost as ɵDomSharedStylesHost, ELEMENT_PROBE_PROVIDERS as ɵELEMENT_PROBE_PROVIDERS, ELEMENT_PROBE_PROVIDERS__POST_R3__ as ɵELEMENT_PROBE_PROVIDERS__POST_R3__, HAMMER_PROVIDERS__POST_R3__ as ɵHAMMER_PROVIDERS__POST_R3__, HammerGesturesPlugin as ɵHammerGesturesPlugin, INTERNAL_BROWSER_PLATFORM_PROVIDERS as ɵINTERNAL_BROWSER_PLATFORM_PROVIDERS, KeyEventsPlugin as ɵKeyEventsPlugin, NAMESPACE_URIS as ɵNAMESPACE_URIS, SharedStylesHost as ɵSharedStylesHost, TRANSITION_ID as ɵTRANSITION_ID, errorHandler as ɵangular_packages_platform_browser_platform_browser_a, _document as ɵangular_packages_platform_browser_platform_browser_b, BROWSER_MODULE_PROVIDERS as ɵangular_packages_platform_browser_platform_browser_c, createMeta as ɵangular_packages_platform_browser_platform_browser_d, createTitle as ɵangular_packages_platform_browser_platform_browser_e, initTransferState as ɵangular_packages_platform_browser_platform_browser_f, EventManagerPlugin as ɵangular_packages_platform_browser_platform_browser_g, HAMMER_PROVIDERS__PRE_R3__ as ɵangular_packages_platform_browser_platform_browser_h, HAMMER_PROVIDERS as ɵangular_packages_platform_browser_platform_browser_i, domSanitizerImplFactory as ɵangular_packages_platform_browser_platform_browser_j, appInitializerFactory as ɵangular_packages_platform_browser_platform_browser_k, SERVER_TRANSITION_PROVIDERS as ɵangular_packages_platform_browser_platform_browser_l, _createNgProbeR2 as ɵangular_packages_platform_browser_platform_browser_m, ELEMENT_PROBE_PROVIDERS__PRE_R3__ as ɵangular_packages_platform_browser_platform_browser_n, GenericBrowserDomAdapter as ɵangular_packages_platform_browser_platform_browser_o, escapeHtml as ɵescapeHtml, flattenStyles as ɵflattenStyles, initDomAdapter as ɵinitDomAdapter, shimContentAttribute as ɵshimContentAttribute, shimHostAttribute as ɵshimHostAttribute }; //# sourceMappingURL=platform-browser.js.map","map":null,"metadata":{},"sourceType":"module"}